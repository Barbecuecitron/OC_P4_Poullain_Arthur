from view.chest_management_view import *
from model.tournament import *
import os.path
from os import listdir
from tinydb import TinyDB, Query
import random
import datetime

print('Controller imported correctly')

def add_player(tournament):
    spark_home = os.path.abspath(os.path.join(os.getcwd(), '../joueurs'))
    db_file_name = 'classement'
    db = TinyDB(spark_home + '/' + db_file_name + '.json').table('players_classement').all()
    ply = enter_new_player()
   # db.insert(ply)

#def populate(tournament):
 #   classement_file = os.path.abspath(os.path.join(os.getcwd(), '../joueurs/'))
  #  if len(listdir(classement_file)) < 1:
   #     print("Il n'y a aucun joueur dans la DB")
    #    print('Relancez le programme puis ajoutez des joueurs pour commencer un tournoi')
     #   quit()
   # ply = pick_player_from_plylist(classement_file)

    #if len(tournament.players) < 8:
     #  else:
      #     tournament.AddPlayer(ply['nom'], ply['prenom'], ply['date'], ply['sexe'])
       #     print(str(len(tournament.players)) + ' joueurs sur 8')
        #    populate(tournament)

#    else:
    #    manage_tournament(tournament)


def fake_populate(t):
    players_ex = [['De Gaulle', 'Charles', '11/02/1965', 'homme'],
                  ['Bonaparte', 'Napoleon', '11/02/1925', 'homme'],
                  ['Hudson', 'Saul', '11/02/1815', 'homme'],
                  ['Duchamps', 'Marcel', '11/02/1815', 'homme'],
                  ['Poullain', 'Arthur', '11/02/1815', 'homme'],
                  ['Smith', 'Patti', '11/02/1815', 'femme'],
                  ['Carson', 'Anne', '11/02/1815', 'femme'],
                  ['Legros', 'LouisVI', '11/02/1815', 'homme'],
                  ['Bigeard', 'Marcel', '11/02/1815', 'homme'],
                  ]
    for i in range(0, 8):
        plyr = Player(str(players_ex[i][0]), str(players_ex[i][1]), str(players_ex[i][2]), str(players_ex[i][3]))
        t.players.append(plyr)

    for ply in t.players:
        ply.points = random.randint(0, 0)
    manage_tournament(t)


def load_tournament():
    spark_home = os.path.abspath(os.path.join(os.getcwd(), '../sauvegardes/'))

    if len(listdir(spark_home)) < 1:
        print("Il n'y a aucune partie sauvegardée.")
        print('Relancez le programme pour continuer')
        quit()
    chosen_db = pick_tournament_to_load(listdir(spark_home))
    file_to_load = spark_home + '/' + chosen_db + '.json'
    db = TinyDB(file_to_load)
    players = db.table('players').all()
    if len(db.table('tournament')) < 1:
        print('Le tournoi nest pas valide, il na pas pu se charger correctement')
        quit()
    t = db.table('tournament').all()[0]
    tournament = Tournament(t['nom'], t['lieu'], t['date'], t['tours'], t['temps'], t['desc'])
    tournament.phase = t['phase']

    for ply in players:
        pl = Player(ply['nom'], ply['prenom'], ply['date'], ply['sexe'])
        pl.AddPoint(ply['points'])
        tournament.players.append(pl)
    return tournament


def save(tournament):
    spark_home = os.path.abspath(os.path.join(os.getcwd(), '../sauvegardes'))
    print(spark_home)
    db_file_name = tournament.nom or 'sauvegarde' + str(tournament.date)
    db = TinyDB(spark_home + '/' + db_file_name + '.json')

    serialized_players = []
    for ply in tournament.players:
        serialized_ply = {}
        for attr, value in vars(ply).items():
            serialized_ply[attr] = value
        serialized_players.append(serialized_ply)

    players_table = db.table('players')
    players_table.truncate()  # clear the table first
    players_table.insert_multiple(serialized_players)

    serialized_tournament = tournament.Serialize()
    tournament_table = db.table('tournament')
    tournament_table.truncate()
    tournament_table.insert(serialized_tournament)
    # print(serialized_tournament)
    print('Le tournoi a été sauvegardé')

def save_classement(tournament):
    spark_home = os.path.abspath(os.path.join(os.getcwd(), '../joueurs'))
    db_file_name = 'classement'
    db = TinyDB(spark_home + '/' + db_file_name + '.json')

    serialized_players = []
    for ply in tournament.players:
        serialized_ply = {}
        for attr, value in vars(ply).items():
            serialized_ply[attr] = value
        serialized_players.append(serialized_ply)

    players_table = db.table('players_classement')
    players_table.truncate()  # clear the table first
    players_table.insert_multiple(serialized_players)
    print('Le classement a été sauvegardé')

def did_player_already_gamed(player1, player2, tournament):
    for chess_round in tournament.rounds:
        for game in chess_round["games"]:
            if game[0][0] == player1 and game[1][0] == player2 \
                    or game[1][0] == player1 and game[0][0] == player2:
                return True
    return False


def is_player_already_in_a_game(player, games):
    for game in games:
        if game[0][0] == player or game[1][0] == player:
            return True
    return False


def create_pairs(t, phase):
    # print("Le tournoi en est à la phase :" + str(phase))
    if phase == 1:
        # Sorting players by points
        #  sorted_ply = sorted(t.players, key = lambda ply: ply.points)
        # Trier selon le rank
        sorted_players = t.players
        length = len(sorted_players)
        middle = length // 2
        first_half = sorted_players[:middle]  # slice first half
        second_half = sorted_players[middle:]  # slice 2nd half
        #matches_from_round = []
        games = []
        for player_index in range(0,len(first_half)):
            # +1 so the first match isnt displayed as match 0
            #match = (first_half[match_index], second_half[match_index])
            match = ([sorted_players[player_index],0], [sorted_players[player_index + middle],0]) # L'index + la moitié
            games.append(match)
        return games
    else:
        sorted_players = sorted(t.players, key=lambda ply: (ply.points, ply.classement), reverse=True) #/!\ Recalculer les points à partir de l'historique des matchs
        games = []
        for player_index in range(0, len(sorted_players)):
            if is_player_already_in_a_game(sorted_players[player_index], games):
                continue

            for opposite_player_index in range(0, len(sorted_players)):
                # Not the same player
                # Opposite player not already in a game this round
                # Both player not already games together
                if sorted_players[player_index] != sorted_players[opposite_player_index] \
                        and not is_player_already_in_a_game(sorted_players[opposite_player_index], games) \
                        and not did_player_already_gamed(sorted_players[player_index],sorted_players[opposite_player_index], t):
                    games.append(
                        ([sorted_players[player_index], 0], [sorted_players[opposite_player_index], 0]))

                    break
               # t.rounds[int(phase)] = games
        return games

def handle_match(games, tournoi):
    spark_home = os.path.abspath(os.path.join(os.getcwd(), '../sauvegardes'))
    db_file_name = tournoi.nom or 'sauvegarde' + str(tournoi.date)
    db = TinyDB(spark_home + '/' + db_file_name + '.json').table('players')
    round = {}
    now = datetime.datetime.now()
    round['idx'] = 'Round' + ' ' + str(tournoi.phase)
    round['start'] = str(now.hour) + ':' + str(now.minute)
    round['games'] = []
    ply1 =  db.search(Query().prenom == 'Arthur')
    #print(ply1[0].doc_id)
    for i in range(0,len(games)):
        ply1_idx = db.search((Query().prenom == games[i][0][0].prenom) & (Query().nom == games[i][0][0].nom))[0].doc_id
        ply2_idx = db.search((Query().prenom == games[i][1][0].prenom) & (Query().nom == games[i][1][0].nom))[0].doc_id
        matchup = ([ply1_idx], [ply2_idx])
        # Let's increment i since we don't want our first match to be match 0
        round['games'].insert(i + 1,matchup)
    display_match(games)
    round['end'] = str(now.hour) + ':' + str(now.minute)
    tournoi.rounds.append(round)
    save(tournoi)
    save_classement(tournoi)

   # save(tournoi)
    #print(tournoi.rounds)
    pick_results(games, tournoi.phase)


def manage_tournament(t):
    save(t)
    save_classement(t)
    for i in range(0, t.tours):
        print('Génération de matchs pour la phase ' + str(t.phase))
        newgames = create_pairs(t, t.phase)
        handle_match(newgames, t)
        t.phase += 1
        #save(t)


def main():
    should_load = should_create_new()
    if should_load == 'Charger un tournoi':
        print('Nous chargeons une partie existante')
        tournament = load_tournament()
        fake_populate(tournament)
    elif should_load == 'Créer un nouveau tournoi':
        print('Nous créeons un nouveau tournoi')
        tournament = create_tournament()  # View
        tournament_obj = Tournament(tournament['nom'], tournament['lieu'], tournament['date'], tournament['tours'],
                                    tournament['temps'], tournament['desc'])
        fake_populate(tournament_obj)
    elif should_load == 'show_players_from_classement':
        pass
    elif should_load == 'print_rapport':
        pass

if __name__ == '__main__':
    main()
